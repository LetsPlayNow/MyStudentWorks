1)Форму делать не стал, так как пока нет навыков для ее создания, а копипаст не даст мне желаемого
2)Если вы захотите увидеть промежуточные стадии работы программы, просто добавьте пару puts, я удалил их дабы не смущать пользователя объемом выводимой информации.

3)Это первая версия, загружаемая мною на civnote (возможно не последняя)
  Если у меня появится время, я могу переделать проект и изменить принцип работы синт. анализатора и генератора кода (т.к. манера кодирования заметно изменилась), и связать результаты с сайтом.

4)Краткое описание проекта
4.1)Файлы
 - lexAn2.rb  (Лексический анализатор)
 - sintAn2.rb (Синтаксический анализатор)
 - codeGen.rb (Генератор кода)
 - test.rb    (Программа, тестирующая все вышеперечисленное (Трансляция из Милана* в язык С*))

5)Как использовать?
!)Мой проект производит трансляцию по моим грамматикам для языка Милан и С (В приложении (изображения))
Данные грамматики сильно упрощены, но основные моменты из исходных грамматик остались.
5.1)Все файлы из пункта 4.1 должны находиться в 1 папке
5.2)Код исходной программы на языке Милан предварительно заносится в виде строки в конструктор лексического анализатора, вызываемый в test.rb (7 строка)
По умолчанию в строке программа, вычисляющая N-ое число Фибоначчи
#Лексический анализатор
obj = LexAn.new("исходная программа")
5.3)Запуск транслятора производится передачей файла test.rb интерпретатору языка Ruby
Linux Mint: ruby test.rb
5.4)На выходе мы получаем:
 - таблицу лексем
 - таблицу идентификаторов
 - таблица констант
 - зеркально сгенерированный код на С
 - дерево синтаксического анализатора (Милан)
 - дерево на С
 - индексное дерево (NUMERIC_TREE)(см описание в codeGen)
 - Текст входной программы на языке С


 6)Краткий принцип работы
	- Лексический анализатор
	Лексический анализатор работает через хэш
	Он выделяет в строке лексему, пробивает ее через хэш и записывает результаты в таблицу лексем

	-Синтаксический анализатор
	Работает по принципу большого валидатора для программы
	Перебирает все лексемы, посредством вызова функций, отвечающих за разбор того или иного нетерминала
	В зависимости от текущей (иногда и последующих) лексем выбирает какой нетерминал подходит в данном случае.
	Рекурсия присутствует - sequaenceOfStatements() - "Последовательность нетерминалов"

	-Генератор кода
	Заменяет все правила вывода в дереве их идентификаторами из таблицы
	Затем по идентификаторам собирает аналогичное дерево на языке С
	Далее дерево сворачивается в программу и корректируется, затем выдается пользователю
